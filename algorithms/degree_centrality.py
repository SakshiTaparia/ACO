# -*- coding: utf-8 -*-
"""Degree_Centrality.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yi3br5aANcv9H5mT8ew6-NxpGcNeeiBp
"""

import numpy as np
import sys

import matplotlib.pyplot as plt
import cv2

# density = np.genfromtxt('Density.csv', delimiter=",")
# density = np.array(density)

# print(density.shape)
# plt.imshow(density)

# d_max = np.amax(density)
# d_min = np.amin(density)

# new = (density - d_min)/(d_max - d_min)
# new = new*10000

# new = np.clip(new, 0, 255)
# print(np.amax(new))

# kernel = np.ones((3,3), np.uint8)
# new = cv2.dilate(new, kernel, iterations=1)

# plt.imshow(new)

junction = np.genfromtxt('Junction.csv', delimiter=",")
junction = np.array(junction)
junction = junction[1:, :]

# print(junction)
print(junction.shape[0])

total = junction.shape[0]
input_file = np.zeros((total, 2))

input_file[:,0] = (junction[:, 2] + 3900 + 121.7)/100
input_file[:,1] = junction[:, 4]

## 0 - cost
## 1 - degree

input_file

budget = 1500

output_file = np.zeros((total))

N = total - 1
DP = np.zeros((total, budget+1))

for b in range (0, budget+1):

	if(b >= input_file[N,0]):
		DP[N,b] = input_file[N,1]

for j in range (0, N-1):
  
  i = int(N-2-j)

  for b in range (0, budget+1):

    if(b >= input_file[i,0]):
      
      temp1 = DP[i+1,b]
      temp2 = DP[i+1,int(b-input_file[i,0])] + input_file[i,1]
      DP[i,b] = np.maximum(temp1, temp2)

    else:
      DP[i,b] = DP[i+1,b]

B = int(budget)

for i in range (0, N-1):

  if (DP[i,B] == DP[i+1,B]):
    output_file[i] = 0

  else:
    output_file[i] = 1
    B = int(B - input_file[i,0])

if(DP[N-1, B] > 0):
  output_file[N-1] = 1

else:
  output_file[N-1] = 0

print(np.count_nonzero(output_file))

## Manually change from convBoundary

import numpy as np
boundary = np.array([0.00,0.00,4224.15,11360.21])

def coordinates(pos, y_max):

  cell = 10

  x = pos[0] if pos[0]>=boundary[0] else boundary[0]
  y = pos[1] if pos[0]>=boundary[1] else boundary[1]
      
  x = int(x/cell)
  y = int(y/cell)

  return(x,y_max-y)

# density = np.genfromtxt('Density.csv', delimiter=",")
# density = np.array(density)

# d_max = np.amax(density)
# d_min = np.amin(density)

# new = (density - d_min)/(d_max - d_min)
# new = new*1000

# new = np.clip(new, 0, 255)

# kernel = np.ones((3,3), np.uint8)
# copy = cv2.dilate(new, kernel, iterations=1)

# for i in range(output_file.shape[0]):
  
#   if (output_file[i] == 1):
#     x,y = coordinates( np.array([junction[i][0], junction[i][1]]), density.shape[1] )   
#     copy = cv2.circle(copy, (x,y), 24, (255,0,0), 5)

# for i in range(output_file.shape[0]):
  
#   if (output_file[i] == 1):
#     x,y = coordinates( np.array([junction[i][0], junction[i][1]]), density.shape[1] )   
#     copy = cv2.circle(copy, (x,y), 7, (255,0,0), -1)

# plt.imshow(copy)

distance = np.genfromtxt('Distance.csv', delimiter=",")
distance = np.array(distance)

# distance

distance = distance[1:, 1:]
clipped_distance = np.copy(distance)

## Consider single RSU of Trange 243 metres

max_val = np.amax(clipped_distance)
clipped_distance = np.clip(clipped_distance, 243, max_val)

clipped_distance = clipped_distance - 243
clipped_distance = np.clip(clipped_distance, 0, 1)

clipped_distance = 1 - clipped_distance
coverage = np.copy(clipped_distance)

temp = np.zeros((coverage.shape[0], coverage.shape[1]))

for i in range(output_file.shape[0]):
  
  if (output_file[i] == 1):
    temp[:,i] = coverage[:,i]

cov = np.count_nonzero((np.sum(temp, axis=1)))

print(cov)
print(coverage.shape[0])
print(coverage.shape[1])
print(cov*100/coverage.shape[0])